Wave-Orch：多 Agent CLI 工具自动编排系统 PRD
1. 总体目标说明

系统目标与定位： Wave-Orch 是构建在 Wave Terminal 上的多 Agent CLI 工具自动编排系统，旨在实现软件项目从开发到交付的高度自动化。该系统通过智能解析用户意图和项目配置，实现以下目标：

项目自动交付： 能够根据用户的高层描述自动完成代码实现、测试、部署等流程，缩短从需求到交付的周期。

配置智能理解： 自动读取并理解项目和开发环境的配置（如 CLI 工具的设置、插件、MCP 服务器等），据此调整 Agent 行为，减少人工配置成本。

Agent 自动调度： 在单个终端环境中并行调度多个 AI 编程 Agent，高效协同完成复杂任务。系统作为指挥官，根据任务需要选择合适的 Agent，并行执行，达到“1+1>2”的效果（多个 Agent 并行工作的产出远超单个 Agent 连续工作的产出）。

目标用户： 面向无编程能力但高度依赖 AI 自动化的个体用户，例如产品经理、小型创业者或不熟悉代码的业务人员。他们希望利用 AI 来完成代码开发、错误修复、环境配置等工作。Wave-Orch 将提供一种“类开发团队”的自动化体验：用户只需提出需求，系统即可由多个 AI Agent 分工协作完成，实现零编码背景下的项目开发与交付。

2. 关键使用场景

Wave-Orch 将在以下关键场景中提供价值：

修复代码错误（Bug Fix）： 当用户遇到代码错误或应用异常时，只需描述问题，系统就会指派合适的 Agent（如 Claude Code）定位问题源头并自动修改代码完成修复。同时可能启用另一Agent对修改进行验证，确保问题真正解决，减少用户手动调试的负担。

自动生成代码实现需求（Feature Implementation）： 用户以自然语言描述新功能或需求，系统将自动规划实现步骤并由多个 Agent 分工完成。一个 Agent 可以负责生成主要代码逻辑，另一 Agent 审查代码或编写相关文档/注释，确保新功能符合预期并保持代码质量。

配置环境或修改 CLI 工具设置： 用户要求配置开发环境（如安装依赖、设置环境变量）或调整 CLI 工具的设置时，系统能解析这些请求，并让相应的 Agent 执行诸如编辑配置文件、运行安装命令等操作。借助对 Wave Terminal 内部环境的了解，指挥官会协调各 Agent 在不干扰用户环境稳定的情况下完成配置变更。

自动提交、更改提交与部署（自动 PR/Test/Deploy）： 当功能开发或错误修复完成后，系统自动执行后续DevOps步骤：例如由 Agent 运行测试用例、生成测试报告，再由另一Agent 自动整理变更生成 Git 提交并创建 Pull Request（含自动撰写 PR 描述）。通过集成部署脚本的 Agent，系统还能在确认代码通过测试后触发自动部署，将新版本发布到目标环境。

多 Agent 协同调研或数据处理任务： 对于复杂的调研、数据分析任务，Wave-Orch 可利用多个专长不同领域的 Agent 并行工作。例如，一个Agent负责爬取数据，另一个负责数据清洗和分析，还有 Agent 编写总结报告。借助指挥官的全局协调，这些 Agent 能流水线式地完成任务，将复杂任务的各个部分自动衔接起来。

3. MVP（最小可用产品）范围

Wave-Orch 的首版（MVP）将重点实现核心编排功能，具体包括：

多 Agent 并行支持： 系统能够同时调用 Anthropic Claude Code CLI、OpenAI Codex CLI、Google Gemini CLI 等多个 CLI 模型代理，并行在Wave Terminal内部窗口中运行。各 Agent 在各自的终端窗口互不干扰，以提升任务处理的吞吐量。

Wave Terminal CLI 注入与输出捕获： 通过 Wave Terminal 提供的接口（如 wsh 等），指挥官可以向每个Agent的终端会话注入命令或Prompt，并实时捕获其输出文本。这样可实现程序化地驱动CLI Agent，对其进行提问、发送代码片段或命令，并收集回答和执行结果。

读取现有Agent配置： 指挥官在启动时会自动读取本地配置，如 ~/.claude/、~/.codex/ 以及 ~/.aider.conf.yml 等文件。通过读取这些配置，系统可获取各 Agent 所需的API密钥、全局说明（instructions.md）、插件和工具权限等，使各Agent能无缝结合用户既有设置运行。例如，从 Codex CLI 的配置文件获取默认模型和审批模式，从 Claude Code 配置读取全局 CLAUDE.md 指令和已安装的插件/工具权限等。配置读取过程中，会自动忽略敏感信息字段，防止这些信息在日志中明文暴露。

统一的 Agent 输出报告（JSON 格式）： 约定每个 Agent 在完成自己当前子任务后，都以 JSON 格式输出一份 REPORT 报告。其中包含标准字段：status（任务状态或结果简述）、actions（该Agent执行的操作列表，例如编辑了哪些文件、运行了哪些命令）、files_changed（文件修改清单及摘要）、test_summary（如有测试则简要说明通过/失败情况）以及next_prompt（该Agent建议的下一步动作或需要的信息）。例如，一个 Agent 完成了Bug修复，可能输出 status: "fix_completed", files_changed: ["app.js"], test_summary: "All unit tests passed", next_prompt: "Proceed to code review"}。JSON 格式便于指挥官程序解析。

指挥官自动仲裁与任务续行： Wave AI 指挥官模块汇总所有 Agent 的 REPORT 输出后，会分析各Agent的状态和建议，自动决定下一轮任务如何进行。例如，如果多个Agent完成的子任务可以合并，指挥官会生成下一个整合步骤的提示；若某个Agent报告需要额外信息或遇到阻塞，指挥官则协调其他Agent提供帮助或调整任务顺序。整个过程采用状态机驱动，每一轮根据上一轮结果动态生成对各Agent的新提示，实现无人值守的流水线式执行。

日志记录与审计： 系统将所有交互日志和结果保存到本地目录 ~/.wave-orch/logs/ 下。按照日期归档，每次完整的编排任务拥有独立日志文件（JSON 格式汇总报告），包含各轮Agent输出报告、指挥官决策和最终结果，方便事后审计和问题追查。

错误容错与超时处理： 如果某一Agent在执行过程中出现错误或长时间无响应（超过预设最长等待时间7分钟），指挥官会自动中止该Agent当前动作，并尝试切换其他Agent接替任务。例如，当Codex CLI卡住无法给出结果时，系统可终止其进程并让Claude Code或Gemini接手处理相同问题。7分钟的超时设置用于避免无限等待，占用系统资源。

Git 分支变更隔离与合并： 为避免多Agent并行修改发生冲突，每个Agent对代码库的修改都在独立的Git分支上进行。Wave-Orch在启动任务时为每个Agent创建一个单独分支（或Git工作区）来应用该Agent的修改。这保证了即使多个Agent同时编辑代码，也不会直接冲突覆盖。任务结束时，由Claude Code代理担当“合并工程师”，检查各分支修改并将它们合并回主分支（或发起Pull Request）进行整合。如有冲突，Claude Code将尝试自动合并或在报告中提示人工介入。此机制借鉴了多Agent编排工具的最佳实践，通过隔离工作区确保协同安全。

4. 系统模块划分

MVP 系统由多个子模块组成，各司其职，共同实现Wave-Orch的功能：

Agent Registry（Agent 注册表）： 管理系统支持的所有 AI Agent的信息，包括Agent名称、启动命令、提示模板、输入/输出格式协议等。它相当于Agent的元数据中心，方便指挥官按需调用。

Orchestration Engine（编排引擎）： 系统核心调度模块，以状态机方式协调多Agent工作。负责任务分解、Agent 任务指派、并行执行控制，以及汇总结果并决定后续动作等。

Wave Bridge Layer（Wave 桥接层）： Wave Terminal 的集成桥接模块。实现向Wave内部的CLI终端窗口注入文本指令、捕获Agent输出并转发给指挥官，同时可以通过Wave Terminal API控制终端窗口（例如打开新窗口、重启会话等），确保指挥官能全面操控各Agent会话。

Config Inspector（配置检查器）： 负责读取和解析用户以及项目的配置文件，例如各Agent的本地配置 (~/.claude/下的设置、Codex的~/.codex/config.yaml、Aider的.aider.conf.yml等)、已安装的插件列表、MCP（模型上下文协议）服务器配置、hooks脚本以及安全规则。该模块在任务开始时为指挥官提供环境情报，并在运行中对敏感信息进行监控和脱敏处理。

Project Tracker（项目跟踪器）： 管理当前运行的项目上下文，可同时跟踪多个项目任务。维护每个项目对应的代码仓库路径、Git 分支/工作区信息、各Agent负责的任务部分，以及项目专属配置（保存在项目.wave-orch/目录下）。确保多个项目的编排互不干扰，并能在任务完成后持久化项目的Agent活动记录。

Output Reporter（输出报告器）： 负责收集整理所有Agent的REPORT输出和执行日志，生成结构化的任务结果报告。该模块还承担日志持久化，将重要的执行记录和最后结果写入日志文件，供用户查看历史和分析。它保证报告格式一致性，并提供必要字段（状态、改动、建议等），方便日后扩展为更丰富的报告形式（例如HTML或Web可视化）。

5. 每个模块功能点与接口需求

下面详细描述各模块的功能要点及需要提供的接口。

Agent Registry（Agent 注册表）

Agent 注册表模块主要负责管理系统所支持的各类 CLI Agent 定义，确保指挥官能够以统一方式与不同Agent交互。其功能和接口需求包括：

Agent 元数据定义： 为每种支持的 Agent 定义一个配置项，内容包括：

name：Agent名称标识（例如 "ClaudeCode"，"OpenAI_Codex"，"GeminiCLI"）。

exec_cmd：启动该Agent会话的命令，例如 claude、codex、gemini 等。这包括必要的参数（如模型选择、API键设置）或执行脚本路径。

input_format：指挥官发送指令的格式要求。例如部分Agent可能要求特定前缀或特殊命令触发，对于一般对话则为纯文本。

output_format：Agent 输出结果的预期格式。MVP要求所有Agent在完成任务单元后输出JSON报告，为此应在注册表中描述如何从该Agent捕获或提取REPORT JSON段落。如果Agent支持自定义Prompt模板，将在Prompt中指示它以JSON格式回答。

指令模板与工具映射： 为标准化各Agent的使用方式，注册表可以存储每个Agent的对话指令模板或特殊命令。例如：Claude Code需要以/command方式运行shell，Codex CLI使用特定前缀标识代码片段等。注册表应提供这些信息，方便 Orchestration Engine 根据Agent类型生成正确的提示或命令。

输出协议转换： 如果某些Agent不能直接输出JSON，注册表模块需要提供对应的解析适配器，将Agent的自由格式输出转换为符合系统规定的REPORT { ... } JSON结构。接口上，可提供例如 parse_output(agent_name, raw_output) -> report_json 方法，对不同Agent实现不同解析规则。

接口设计： 对 Orchestration Engine 提供查询接口，例如 get_agent_list() 列出可用Agent，get_agent_config(name) 获取特定Agent的元数据配置，以及用于动态添加新Agent的接口（为未来插件机制做准备）。这些接口使编排引擎无需了解具体Agent细节，通过注册表查询即可得到所需信息。

Orchestration Engine（编排引擎）

编排引擎是Wave-Orch的大脑，负责跨Agent协调任务执行。其功能和接口需求包括：

任务状态机管理： 以状态机驱动整个编排过程，从 初始化 -> 任务分解 -> 并行执行 -> 结果收集 -> 决策下一步 -> 结束 等阶段流转。引擎需要维护一个全局状态（如当前轮次、进行中的Agent任务列表、已完成任务列表），并根据状态和Agent反馈决定状态迁移。接口设计上，引擎应提供 start_task(project, user_request) 启动新任务，以及内部使用的 advance_state() 或 handle_report(agent_report) 方法，在收到Agent报告时推进状态机。

任务分解与指派： 根据用户请求或上一状态的需要，将整体任务划分成可并行或有序的子任务。例如，用户请求一个新功能，则引擎可能拆分为“实现功能代码”、“撰写测试”、“更新文档”三个子任务，分别指派给不同Agent执行。在接口上，引擎应与Agent Registry 协作，根据任务类型选择合适Agent，并通过 Wave Bridge Layer 向其发送指令。需要支持同时向多个Agent发出指令的并行调度（例如不同窗口并行运行）。

并行执行控制： 在多Agent并行运行时，引擎需要跟踪每个Agent会话的状态，防止资源冲突或死锁。应实现基本的锁和依赖机制：例如若两个Agent可能修改同一文件，引擎需确保任务拆分时已避免这种冲突（或在检测到潜在冲突时串行化这些Agent的执行）。可以借鉴 Agent Farm 等工具的做法，用“文件锁”或范围锁防止冲突。MVP阶段简化处理：通过预先任务划分让每个Agent修改独立模块或文件集合，以降低冲突概率。引擎接口需要提供对并行任务的监控方法，如 check_conflicts(agent_reports) 来检查报告中是否有重叠修改，并在下一轮决策中予以合并或调整。

结果整合与决策： 当一轮并行任务完成后，编排引擎收集所有Agent的REPORT JSON，通过分析这些报告来更新全局状态并决定后续动作：

若所有子任务都成功完成，则进入收尾阶段（例如进入测试/部署或直接结束）。

若有任务完成但引出新的工作（例如Agent建议了下一步操作next_prompt），则生成新一轮的指令，可能继续指派给同一Agent或其他Agent。

若有任务失败或未完成，引擎将决定是重试（可能换一个Agent重试失败的任务）还是请求用户输入。

引擎需要实现自动仲裁逻辑：当多个Agent报告内容存在冲突或不一致时（例如两个Agent对同一功能给出不同实现），引擎可以根据优先级策略选择其中一个方案，或者把冲突留待最终Claude Code合并时解决。接口上，可提供 decide_next_actions(reports) -> List[AgentCommands] 函数，输出对各Agent的下一步指令列表或者结束信号。

超时与错误处理： 引擎应处理Agent超时或异常情况。如果某个Agent在预定时间未返回报告，引擎可以终止该Agent会话（通过Wave Bridge Layer发出终止命令）并记录超时。同时按照MVP策略，尝试改由其他备用Agent执行相同任务。若Agent报告错误（例如执行命令失败、测试未通过），引擎应能够解析报告中的错误信息，决定是再次尝试修复（可能提示同一Agent进一步行动）还是切换Agent处理。需要一个 on_agent_error(agent_name, error_info) 接口用于统一处理失败情况。

Wave Bridge Layer（Wave 桥接层）

Wave 桥接层负责Wave-Orch与Wave Terminal环境的交互，是执行层面的关键模块。其功能点与接口要求：

终端会话管理： 能通过Wave Terminal提供的API（如Wave的CLI或SDK）打开和管理多个内部终端窗口，每个窗口运行一个Agent CLI 实例。桥接层需要能够启动新终端（指定执行Agent的启动命令），以及在需要时重置终端会话或关闭窗口。接口例如 open_agent_terminal(agent_name) -> window_id，close_terminal(window_id) 等，用于生命周期管理。

命令注入： 允许指挥官将文本指令发送到指定终端窗口，即模拟用户在该终端输入命令/对话。Wave Terminal的AI模式通常支持将AI助手的输出注入命令行，Wave 桥接层需利用这机制实现程序化注入。例如，通过调用 wsh 命令或 Wave Terminal 提供的WebSocket/API，将一段字符串发送到特定终端。显示了Wave Terminal文档提到的CLI集成功能，表明可从外部驱动内部终端。桥接层接口设计可为 send_command(window_id, text)，内部封装Wave Terminal的相应调用。

输出捕获： Wave Terminal AI模式允许AI读取终端的输出内容。桥接层应实现对每个Agent终端输出的持续监听，实时捕获新增的stdout文本，并传递给指挥官进行解析。需要注意区分不同Agent窗口的输出，维护一个缓冲或事件回调，例如当终端输出更新时调用 on_output(window_id, new_text)。尤其要能够检测到Agent输出中的特殊REPORT {..}段落，以便及时传给Orchestration Engine处理。实现时可能结合Wave Terminal的“Widget Context”功能，让AI指挥官读取各终端块的内容。

窗口控制与布局： 为提升用户可视体验，桥接层也可以提供对Wave Terminal UI的控制，比如在侧边栏显示指挥官状态、自动排列终端窗口等。MVP中可简单实现按需开启/关闭窗口；未来可扩展为自动布局（例如类似Ghostty一次展示多个终端pane）。接口上，可考虑 focus_window(window_id) 切换窗口焦点，split_windows(layout_config)按照给定布局展示多个窗口等。

Config Inspector（配置检查器）

配置检查器模块在任务开始时和运行过程中发挥“情报官”的作用，确保各Agent运行环境正确，并保护敏感信息安全。主要功能和接口：

全局/项目配置读取： 启动时扫描用户主目录和当前项目目录下与各Agent相关的配置文件：

Claude Code：读取 ~/.claude/ 目录（如 settings.json、CLAUDE.md 指令集、已安装插件列表等）、以及项目下 .claude/ 子目录（项目特定的配置）。

Codex CLI：读取 ~/.codex/ 目录下的配置文件（如 config.yaml、全局 prompt 指令 instructions.md 等），获取OpenAI API Key、默认模型、审批模式等设置。

Aider 等其他Agent：检查如 ~/.aider.conf.yml（如果存在）或者项目根目录的 .aider.conf.yml来应用用户偏好的参数配置。

其他：读取 ~/.wave-orch/config.json 用户偏好，以及项目目录下 .wave-orch/ 中的任务配置（详见第7节）。
配置检查器提供接口如 load_agent_configs(project_path) 返回解析后的配置对象供指挥官使用。载入配置时会进行格式校验，并记录关键参数（如各Agent API Key是否可用、MCP服务器地址等）。

插件和工具检查： 部分Agent支持插件或外部工具（例如Claude Code的插件市场，Codex的工具列表、Anthropic的MCP hooks）。配置检查器应解析配置中plugins列表、hooks脚本配置、MCP服务器列表等。据此，指挥官能了解Agent可用的扩展能力。例如如果检测到Claude Code加载了GitHub插件，则可以允许Agent调用MCP读取GitHub Issue等。接口可以是 get_agent_capabilities(agent_name)，返回如 {plugins: [...], tools: [...]} 信息。

安全规则应用： 读取各Agent配置中的安全权限规则（allow/deny 列表）并在系统级别应用，防止敏感操作未经许可发生。例如Claude Code的全局设置可能拒绝Agent读取本地.env或执行未经允许的网络请求。配置检查器应收集这些规则，提供统一的安全策略给Orchestration Engine参考，使指挥官在发送任务时避免触发被拒绝的操作。同时，敏感信息脱敏是一大职责：对于配置中发现的API Key、密钥、邮箱等敏感数据，绝不直接发送给LLM Agent。例如，当Agent需要验证权限时，指挥官可以采用占位符或预先设定的方法注入，而不暴露真实值（如不直接把密钥明文作为对话内容）。配置检查器可以实现一个 redact_sensitive(content) 方法，将日志或对话中的敏感字符串用掩码替换，并在需要时提示用户在本地完成相关认证步骤。

动态配置监控： 在长时间运行过程中，如果用户修改了相关配置（例如替换了API密钥、添加新的插件），配置检查器可以监听这些文件的变化并及时通知系统。MVP中可不实现热加载，但设计上应考虑提供 reload_config() 接口以供未来手动或自动触发配置更新。

Project Tracker（项目跟踪器）

项目跟踪器负责在多项目并行支持和项目上下文管理中发挥作用，使Wave-Orch可以同时服务于多个开发项目且有条不紊。功能与接口需求：

项目上下文隔离： 当用户在Wave Terminal中打开多个项目或目录时，项目跟踪器需要为每个项目维护独立的上下文。具体包括：

记录项目路径、名称以及关联的Git仓库URL（如果有）。

分配每个项目各自的Agent会话组和编排状态机实例，确保不会串扰。

加载项目特定的配置（通过Config Inspector）并在任务执行时提供给相应的编排引擎。
接口上，start_project_session(project_path) 用于初始化一个项目的跟踪记录，get_project_context(project_path) 返回相关的Agent列表、配置等。

多项目并行调度： 如果目标用户需要在多个项目间切换任务，Wave-Orch应支持保持多个项目任务的挂起状态。项目跟踪器需要与Orchestration Engine协同，管理每个项目独立的任务队列和状态。当用户切换到某项目时，加载其最近的任务状态；当在项目A任务执行期间，项目B有新的任务，也可以启动另一套编排流程并行进行（取决于系统资源）。需要设计任务ID或项目ID机制，以标识日志和报告归属。接口如 list_active_projects() 列出当前正在编排的项目及各自任务状态，以便Wave AI指挥官在侧边栏显示概览。

Git 分支/工作区管理： 如第3节所述，每个Agent的改动在独立Git分支进行。项目跟踪器需记录这些分支与项目的对应关系，方便稍后合并和清理。例如维护一个映射：{ 项目ID: { agentName: branchName, ... } }。当任务完成合并后，项目跟踪器可以触发删除临时分支或保留快照供审查。接口可以包括 assign_branch(project, agent) -> branchName（创建并分配分支），cleanup_branches(project)（合并完成后清理临时分支）等。

项目配置存储： 项目跟踪器负责在项目根目录创建并维护一个 .wave-orch/ 隐藏文件夹，用于存放该项目相关的Wave-Orch配置和状态。例如:

.wave-orch/config.json：项目特定的配置（如排除某些文件、指定优先Agent等）。

.wave-orch/history.log：项目运行日志的简要索引，记录过去的任务ID、日期和状态，方便快速查询。

.wave-orch/branches.txt：当前任务使用的临时分支列表。
这些文件由项目跟踪器读写，接口如 save_project_state(project) 和 load_project_state(project) 负责持久化/恢复项目的运行状态。

Output Reporter（输出报告器）

输出报告器模块汇总各Agent的输出并生成最终呈现给用户和日志的报告，是Wave-Orch与用户以及外部审计交互的出口。功能和接口包括：

REPORT汇总与格式化： 当一轮或整个任务完成后，Output Reporter 收到 Orchestration Engine 提供的所有Agent REPORT数据和总体任务结果。它将这些信息融合形成结构化的总结报告。报告包括：

任务概况： 例如任务执行用时、参与的Agent列表、任务最终状态（成功/失败/部分完成）。

步骤记录： 按时间顺序列出各主要步骤，每步由哪个Agent执行、执行内容摘要及结果。例如：

Claude Code 完成了代码修改（列出改动文件和简述修复内容）。

Codex CLI 编写了单元测试（测试通过率摘要）。

Gemini CLI 审核代码并建议性能改进。

最终代码变更摘要： 汇总所有合并后的代码改动列表，可能包括行数统计、重要逻辑更改说明。

后续建议： 如果任务没有完全成功或者有可改进之处，结合Agent建议给出下一步行动建议，比如“需要人工审核数据库迁移文件”或“可进一步优化算法性能”。
Output Reporter 将以上内容组织成统一的Markdown或JSON格式，以便用户阅读或机器进一步处理。未来版本中，可拓展生成更友好的HTML报告或在Wave侧边栏以富文本呈现。

日志落盘： Output Reporter 与日志系统接口，将关键报告数据持久保存到 ~/.wave-orch/logs/ 相应文件中。一份完整任务的JSON汇总报告将包含所有上述内容，保存文件名可采用时间戳或任务ID命名，存放在日期分隔的目录下（例如 ~/.wave-orch/logs/2026-01-29/task-163244.json）。日志保存过程中，Output Reporter 应该确保敏感信息已脱敏（结合 Config Inspector 的redact机制），并包括元数据如软件版本、使用的模型版本等以供日后分析。

实时反馈接口： 在用户界面交互上，Output Reporter可以通过Wave AI指挥官在侧边栏即时显示当前任务的阶段性结果。例如，当某Agent完成子任务输出REPORT时，Output Reporter将提取其中关键内容（如进度百分比、当前状态）更新到Wave Terminal侧边栏，令用户对漫长过程中的进展心中有数。接口可能与Wave Terminal的API集成，如利用Wave AI Assistant显示富文本消息的能力，将报告的概要/进度发送到UI。

接口设计： 提供如 generate_report(task_id, reports_list) -> report_object 用于生成报告数据结构，save_report(report_object, file_path) 用于保存日志文件，notify_user(report_object, channel) 用于通过UI通知用户的功能。其中 channel 可以是Wave Terminal的侧边栏、系统通知等。MVP阶段，主要实现文件保存和终端侧边栏输出两种渠道。

6. 安全策略与默认权限

安全策略在Wave-Orch中至关重要，系统将默认启用严格但不打扰用户的安全权限配置，以确保自动编排不会带来意外风险：

全流程零确认模式： 除非遇到业务逻辑不明或高风险操作需要人工裁决，默认情况下Wave-Orch在编排过程中不需要用户手动批准各项步骤。这意味着系统将以“全自动”模式运行，最大化自动化程度。类似于Codex CLI的full-auto模式，绝大多数Agent执行（包括文件改动、运行测试、安装依赖等）均不弹窗确认，以符合目标用户无需编程干预的预期。如果某一步骤涉及业务决策（例如选择实现方案）且Agent无法确定，才会暂停请用户选择。

默认允许的操作： 系统预先信任并允许一系列常规开发相关操作，不视为敏感危险：

文件修改： 允许Agent对项目中文件进行读取、创建、编辑和删除。这是实现代码变更的基本功能，默认开放。

命令执行： 允许Agent在终端执行常规shell命令，例如构建、测试、运行lint、启动开发服务器等。Codex/Claude等Agent内部往往已内置白名单策略（如允许npm run test等），Wave-Orch在此基础上对常见开发命令不做额外限制。

网络请求： 允许Agent发起互联网请求用于安装依赖包（如调用pip install、npm install）或获取必要的公共数据。但为了安全，禁止直接向未知地址发送敏感数据。必要情况下通过配置允许访问特定API。

依赖安装： 允许Agent根据需要安装项目依赖或系统依赖（例如通过包管理器），以完成任务所需的环境准备。

Git 提交与推送： 允许Agent执行git add/commit以及（在用户有设置远端的情况下）git push操作，以提交代码变更并与远程仓库交互。这对于自动PR和部署流程是必须的。在Claude Code配置中，这类操作可以设置为无需确认（如允许Bash(git diff *)等），Wave-Orch将沿用类似策略。

敏感操作默认拒绝： 为防范潜在危险，Wave-Orch整合各Agent的安全配置，对以下操作设置默认拒绝或人工确认：

访问敏感文件： 如读取包含机密的配置(.env、包含密钥的文件、SSH私钥等)，默认禁止Agent直接访问。这样即使Agent自主尝试，也会被安全层拦截。

外部请求包含密钥： 禁止Agent通过curl或HTTP请求直接发送包含明文密钥/令牌的参数。若确需调用外部API，需采用密钥脱敏代理方式。

破坏性系统命令： 如格式化磁盘、删除非项目文件、修改系统设置等显然超出开发范围的命令，一律不执行。同时，对网络访问也有限制，如Codex CLI沙箱模式那样，在全自动下仅允许访问特定域名/IP（例如只允许模型API，不允许随意访问互联网）。Wave-Orch将利用Claude Code等的沙盒功能（macOS Seatbelt、Linux iptables等）对Agent执行环境做隔离，防止危及宿主机安全。

密钥与机密脱敏： 绝不发送明文密钥、令牌到外部模型。 配置检查器会识别出用户环境中的敏感信息（API Keys、Tokens、邮箱等），在与Agent交互时用占位符或摘要替代。例如，若Agent需要调用GitHub API且用户提供了Token，指挥官不会直接给Agent令牌，而是本地调用相关操作或提示用户手动完成授权。日志中也不会记录明文机密，Output Reporter在保存前会执行脱敏处理（如用***遮蔽字符串的一部分）。通过结合Claude Code权限配置和自定义hooks，确保无敏感数据泄露：显示的默认deny规则就是典型例子，Wave-Orch会遵循这些安全基线。

用户确认机制： 对于极少数必须用户决策的情况（如Agent在代码改动中涉及逻辑判断、可能影响业务正确性的变更），Wave-Orch会暂停并在Wave Terminal侧边栏通过Wave AI指挥官提示用户审阅。用户可以通过自然语言回答，例如“接受修改A方案”或“选择回滚更改”，指挥官再将此作为新的Prompt引导Agent继续。整个流程设计力求减少对用户的打扰，在默认安全策略下，绝大多数操作将自动安全地完成。

7. 数据与日志目录规范

为方便调试、审计以及多次运行间的信息共享，Wave-Orch 对数据和日志存储做出如下规范：

日志存储（Logs）： 所有运行历史日志保存在用户主目录下的 ~/.wave-orch/logs/ 目录。按照日期归档，每一天创建一个子文件夹，如 ~/.wave-orch/logs/2026-01-29/。在每个日期文件夹中，每次完整的任务执行（从启动到结束，包括可能的多轮Agent交互）记录为单独一个JSON文件。例如，某次任务可能记录为 2026-01-29_19-47-01_project-shopping-cart.json，文件名可包含时间戳和项目名称/任务简述。日志JSON内容由 Output Reporter 生成，包含任务的元数据（任务ID、项目名称、启动时间、所用Agents列表等）以及 report 字段存放完整的结构化报告。这样设计便于机器解析和人阅读。例如可以用脚本汇总最近一周内的失败任务统计。所有日志记录只追加不修改，方便事后追溯每个任务的经过。

项目配置与状态（Project Data）： 每个项目仓库下创建隐藏目录 .wave-orch/，用于持久保存该项目相关的Wave-Orch配置和执行状态：

.wave-orch/config.json：项目配置文件，记录该项目定制的设置。例如指定默认使用哪些Agent（也可由系统自动填写最近常用的Agent列表）、忽略哪些文件或目录不让Agent修改、项目所需的环境变量键值对（脱敏存储）等。用户可以编辑此文件调整Wave-Orch对该项目的行为。

.wave-orch/state.json：项目状态文件，记录当前或上一次任务的关键状态，如尚未完成的任务队列、各Agent临时分支名、最近一次运行时间等。这样当用户中断后稍后可以续接任务，或者供Wave-Orch在并行处理多个任务时快速恢复上下文。

.wave-orch/history/：历史报告存档（可选）。在项目目录下再按任务ID或日期存放每次任务Output Reporter输出的报告摘要，内容与全局日志类似但只包含与该项目相关的信息。这是为方便团队协作查看项目AI活动历史，也使得即使移动或复制仓库，历史报告可随项目走。

权限： .wave-orch/目录默认加入Git忽略（.gitignore），以避免将本地配置泄露到版本库。但其中如有需要分享的配置（比如团队决定启用某插件），用户可手动提交特定文件。

全局用户配置： Wave-Orch 的全局配置文件位于 ~/.wave-orch/config.json。该文件用于存储用户偏好和全局默认设置。例如：

用户的OpenAI/Anthropic API密钥存放位置（可存引用，不明文存储）、默认模型选择（Claude Code vs Claude Instant 等）、日志保留期限设置等。

并行Agent数量限制（如硬件资源限制下最多同时跑几个Agent会话）。

默认超时时间配置（如7分钟可在此调整）。

UI 偏好（是否显示实时进度通知、是否启用声音提示等）。
Wave-Orch在启动时会读取该文件（通过Config Inspector），并根据其中设置调整行为。如果文件不存在，会在首次运行时创建一个带默认值的模板供用户调整。

通过上述分级的日志和配置存储机制，Wave-Orch 实现了运行即记录、配置可携带。用户可以方便地查看过去AI自动编排做了什么，更好地信任和掌控系统行为；同时不同项目的偏好和状态相互隔离，又可由全局配置进行统一管理。

8. 后续扩展建议

在MVP功能基础上，未来Wave-Orch可以考虑以下扩展方向，以增强系统能力和用户体验：

远程Agent分布支持： 当前版本聚焦于单机（macOS）运行，未来可扩展为在多机器/远程环境调用Agent。例如通过SSH连接远程服务器，在其中启动Agent CLI。这将允许将繁重任务分担给云端或其他高性能机器执行，也能实现在不同环境（如同时在Linux服务器和本地Mac上执行不同任务）的协同。需要在Orchestration Engine中加入远程执行模块，管理SSH会话或通过API触发远端Agent运行，汇聚结果后仍由本地指挥官决策。

插件机制： 开放Wave-Orch的Agent注册表，让用户可以添加自定义Agent脚本。例如用户自己实现了一个AI CLI工具或想集成新的模型，只需编写符合协议的包装脚本，并将其注册到Wave-Orch配置中，即可被系统识别为新Agent参与编排。这种插件机制要求定义清晰的Agent接口规范（输入输出JSON格式、报告字段要求等）和易于注册的方法（可能通过在 ~/.wave-orch/agents.d/ 目录放置描述文件或脚本符号链接）。通过插件化，Wave-Orch 能紧跟AI工具发展，随时扩充新的Agent类型。

Web 控制面板： 除了Wave Terminal内置的侧边栏指挥官，将来可以提供一个Web界面的控制面板。用户可以在浏览器中查看当前所有运行的任务、各Agent状态，实时日志输出，以及历史任务列表。控制面板还可以提供可视化diff查看器，让用户方便地查看每个Agent提交的代码改动并进行对比或回滚历史版本。同时支持在Web UI上触发新任务、停止任务等操作。这对于不方便长时间守在终端窗口前的用户，会是很有帮助的扩展。

多Agent互审机制： 引入Agent 间的互相审核流程，提高最终成果质量。例如Claude Code与Codex可扮演“审稿人”和“作者”的关系：当Codex完成代码生成后，Claude Code自动审查其改动，提出潜在问题和改进建议；反过来Claude完成修复后，Codex再进行测试验证。这样的“双重把关”有望减少错误和漏洞。实现上，Orchestration Engine需要支持配置某任务需要两轮不同Agent处理，并整合审查反馈。例如可以让Claude Code的REPORT中包含review字段，指挥官据此引导Codex做出修改，直到双方输出都满意为止。

更智能的任务规划与拆分： 随着模型能力增强，可考虑引入一个AI Planner Agent（规划者Agent），负责接受用户高层需求后自动制定详细的子任务规划，然后将子任务分配给执行Agent。这有点类似“AI 项目经理”的角色。例如Planner Agent读懂需求后，划分出前端、后端、测试、文档等任务，并标注执行顺序和依赖，指挥官据此调度各专业Agent各司其职。这将减轻当前需要通过规则或简单逻辑拆分任务的负担，让任务拆解更加灵活和智能。

跨仓库协作： 未来版本可支持一个任务涉及多个代码仓库/项目。例如一个新功能需要同时修改后端服务和前端应用，Wave-Orch可以同时在两个项目的上下文中开启Agent（或者在一个Agent的MCP能力下打开跨项目文件）进行协同，最后由指挥官把跨仓库的变更组合成统一的交付结果。这需要Project Tracker扩展对多项目任务的支持，以及Output Reporter在报告中合并多项目改动。

性能和成本优化： 随着Agent数量增加，需考虑优化资源占用和API调用成本。后续可引入Agent调度策略，在本地资源不足时队列等待，或根据任务重要性动态调整并发度。另外，可支持对接本地LLM模型，优先在本地推理，降低云API调用次数。或利用短上下文模型处理简单任务，减少大模型上下文占用的成本。通过这些优化，使得Wave-Orch在应对更大规模任务时仍保持高效且成本可控。

上述扩展为Wave-Orch绘制了清晰的演进路线。通过持续迭代，Wave-Orch将从MVP的一款单机多Agent编排工具，发展为面向未来的分布式AI开发协作平台，更全面地提升非编程用户利用AI开发的能力和体验。